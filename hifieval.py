import re
import sys
import getopt
import argparse
import numpy as np
import pandas as pd
from io import StringIO
import matplotlib.pyplot as plt
from collections import defaultdict
from collections import Counter

class ReadError(object):
    "The class object that stores the errors (indel and mismatch) from each read."
    def __init__(self, readName, strand, chrName, start, end):
        self.readName = readName
        self.strand   = strand
        self.chrName  = chrName
        self.start    = start
        self.end      = end
        self.inPos    = []
        self.delPos   = []
        self.misPos   = []
    
    def __str__(self):
        return '\t'.join([self.readName,self.strand,self.chrName])
    
    def get_error(self,read_cs):
        '''
        Find the errors of a read against the reference using read_cs tag generated by minimap. 
        Append the relative position of the error in the read to each list of error type. 
        CS tag encodes difference sequences in the short form.
        '''
        tmp = read_cs
        if tmp.startswith('cs:Z:'):
            tmp = tmp[5:]
        num = 0
        while len(tmp) != 0:
            # identical
            if tmp[0] == ':':
                identical = re.search(r'\d+', tmp).group()
                num += int(identical)
                tmp = re.sub(r'.', '', tmp, count = 1+len(identical))
            # mismatch
            elif tmp[0] == '*':
                num += 1
                self.misPos.append(num)
                tmp = re.sub(r'.', '', tmp, count = 3)
            # insertion
            elif tmp[0] == "+":
                insertion = ''
                for ch in tmp[1:]:
                    if ch.isalpha():
                        insertion += ch
                    else: break
                num += 1
                self.inPos.append(num)
                tmp = re.sub(r'.', '', tmp, count = 1+len(insertion))
            # deletion
            elif tmp[0] == "-":
                deletion = ''
                for ch in tmp[1:]:
                    if ch.isalpha():
                        deletion += ch
                    else: break
                num += 1
                self.delPos.append(num)
                tmp = re.sub(r'.', '', tmp, count = 1+len(deletion))
            else:
                print("Unexpected error tag: {}".format(tmp[0]))
                break
        return self
    
    def get_reverse_error(self,read_cs):
        '''
        Similar to get_error() but calculate the position for reverse strand.
        '''
        read_len = int(self.end)-int(self.start)+1
        tmp = read_cs
        if tmp.startswith('cs:Z:'):
            tmp = tmp[5:]
        num = 0
        while len(tmp) != 0:
            # identical
            if tmp[0] == ':':
                identical = re.search(r'\d+', tmp).group()
                num += int(identical)
                tmp = re.sub(r'.', '', tmp, count = 1+len(identical))
            # mismatch
            elif tmp[0] == '*':
                num += 1
                self.misPos.append(read_len-num+1)
                tmp = re.sub(r'.', '', tmp, count = 3)
            # insertion
            elif tmp[0] == "+":
                insertion = ''
                for ch in tmp[1:]:
                    if ch.isalpha():
                        insertion += ch
                    else: 
                        break
                num += 1
                self.inPos.append(read_len-num+1)
                tmp = re.sub(r'.', '', tmp, count = 1+len(insertion))
            # deletion
            elif tmp[0] == "-":
                deletion = ''
                for ch in tmp[1:]:
                    if ch.isalpha():
                        deletion += ch
                    else: 
                        break
                num += 1
                self.delPos.append(read_len-num+1)
                tmp = re.sub(r'.', '', tmp, count = 1+len(deletion))
            else:
                print("Unexpected error tag: {}".format(tmp))
                break
        return self
    
    def all_error(self):
        '''
        return a combined list of indel and mismatch positions
        '''
        e = self.inPos + self.delPos + self.misPos
        return e
    
class CorrectionStat(object):
    "The class object for measuring the performance of a Error Correction tool."
    '''
    oc: (over-correction) The errors appeared in corrected reads (corr) but not in raw reads (raw)
    uc: (under-correction) The errors in raw that are still in corr
    cc: (correct-correction) The errors that are in raw but not corr
    '''
    def __init__(self, chrName, readNum=0):
        self.chrName = chrName
        self.readNum = readNum
        self.ocPos   = []
        self.ucPos   = []
        self.ccPos   = []    # correct correction: errors in raw but not in corr
    
    def __str__(self):
        return '\t'.join([self.chrName, str(self.readNum)])
    
    def add_pos(self, ocPos, ucPos, ccPos):
        self.ocPos += ocPos
        self.ucPos += ucPos
        self.ccPos += ccPos
        self.readNum += 1
        return self

    def get_FPR(self):
        # FPR = FP / (TN+FP)
        tc = len(self.ccPos)-len(self.ucPos)+len(self.ocPos) # total correction
        return len(self.ocPos)/tc
    
    def get_FNR(self):
        # FNR = FN / (TP+FN)
        return len(self.ucPos)/(len(self.ccPos)+len(self.ucPos))
    
    def get_TPR(self):
        # TPR = TP / (TP+FN)
        return len(self.ccPos)/(len(self.ccPos)+len(self.ucPos))
    
    
    
def paf_pairs(paf_file1, paf_file2):
    '''generator'''
    with open(paf_file1,'r') as paf1, open(paf_file2,'r') as paf2:
        prev_r = prev_c = None    # paf list
        
        while True:
            try:
                raw_line = next(paf1)
                corr_line = next(paf2)
            except StopIteration:
                break
            
            raw_paf = corr_paf = None
            
            while raw_paf is None:
                raw_paf  = parse_read_paf(raw_line, prev_r)
                if raw_paf is not None:
                    break
                raw_line = next(paf1)
                
            while corr_paf is None:
                corr_paf = parse_read_paf(corr_line, prev_c)
                if corr_paf is not None:
                    break
                corr_line = next(paf2)

            prev_r = raw_paf
            prev_c = corr_paf
            
            yield raw_paf, corr_paf


def parse_read_paf(line, prev_paf):
    '''
    Extract information (readName, strand, chrName, start, end, nbase, cs) 
    for paf file generated by minimap.
    '''
    line = line.rstrip()
    tmp = line.split('\t')
    if len(tmp) < 24: # missing s2 -> not primary alignment
        return None
    
    # take the first appearing read in the paf file
    if prev_paf is not None:
        if tmp[0] == prev_paf[0]:
            return None
    
    indices = [0,4,5,7,8,10,-1]
    # readName, strand, chrName, start, end, nbase, cs
    readpaf = [tmp[index] for index in indices]
    
    return readpaf

def error_corr_helper(raw_plist, corr_plist):
    '''
    Helper method that gets the lists of oc, uc, and cc, respectively.
    plist: a list of positions of one type of errors (in/del/mis) in one raw/corr.
    '''
    # The errors that are in raw but not corr
    cc = set(raw_plist).difference(corr_plist)
    # We thus get under-correction if 2 still has errors from 1
    uc = set(raw_plist).difference(cc)
    # Over-corrections are new in 2 but not in 1
    oc = set(corr_plist).difference(raw_plist)
    # tc = cc - uc + oc
    
    return list(oc), list(uc), list(cc)


def error_correction_eval(raw_paf_file, corr_paf_file):
    '''
    The method that puts it together. 
    The inputs are the paf file names (str) generated by minimap (raw/ref & corr/ref)
    '''
    output = dict()
    # The error correction stats objects stored in dict value
    # for each chromosome stored as dict key
    ercor_tmp = None
    
    for raw_paf, corr_paf in paf_pairs(raw_paf_file, corr_paf_file):
        
        raw_error = ReadError(raw_paf[0],raw_paf[1],raw_paf[2],raw_paf[3],raw_paf[4])
        if raw_error.strand == '+':
            raw_error = raw_error.get_error(raw_paf[6])
        else:
            raw_error = raw_error.get_reverse_error(raw_paf[6])

        corr_error = ReadError(corr_paf[0],corr_paf[1],corr_paf[2],corr_paf[3],corr_paf[4])
        if corr_error.strand == '+':
            corr_error = corr_error.get_error(corr_paf[6])
        else:
            corr_error = corr_error.get_reverse_error(corr_paf[6])
        # check if reads are the same from raw and corrected
        if raw_error.readName != corr_error.readName:
            print('Raw & Corr Read Names do not match for Error Correction Evaluation.')
            print(raw_error)
            print(corr_error)
            return None
        oc, uc, cc = error_corr_helper(raw_error.all_error(), corr_error.all_error())
        
        key = raw_error.chrName
        if key in output:
            output[key].add_pos(oc, uc, cc)
        else:
#             print("Error correction on Chr {}".format(key))
            output[key] = CorrectionStat(raw_error.chrName).add_pos(oc, uc, cc)

    return output




class UnitSTR(object):
    "Object class for Short Tandem Repeat info for one chromosome"
    def __init__(self, chrName):
        self.chrName = chrName
        self.strPos = []
        
        # ***Note: Not sure if we should care about the unit nucleotides 
        
    def add_strPos(self, start, end):
        self.strPos.append((start, end))
        return self
    
    def __str__(self):
        out = self.chrName + "\nNumber of Homopolymers:" + str(len(self.strPos))
        return out
    
    
def find_homopolymers(fa_file):
    '''
    Finds all homopolymers in the fasta file with length > 3.
    The result is stored in a dictionary with each chromosome as key and UnitSTR as value.
    '''
    chrName = unit = start = end = -1
    l = 3
    tmp = None    # the temporary UnitSTR object that will be stored in hp_dict
    hp_dict = {}  # a dict that store homopolymers for each chromosome
    
    with open(fa_file,'r') as f:
        for line in f:
            if line[0] == '>':
                if end - start > l:
                    tmp = tmp.add_strPos(start, end)
                hp_dict[chrName] = tmp
                chrName = line.strip().split()[0][1:]
                tmp = UnitSTR(chrName)
                unit = -1
                start = end = 0
            else:
                for b in line.strip():
                    if b != unit:
                        if end - start > l:
                            tmp = tmp.add_strPos(start, end)
                        start = end
                        unit = b
                    end += 1
        if end - start > l:
            tmp = tmp.add_strPos(start, end)
        
        hp_dict[chrName] = tmp
        del hp_dict[-1]
    return hp_dict


def hp_error_chr_eval(correction_dict, hp_dict):
    '''
    Evaluation of homopolymer error for each chromosome
    '''
    # check if the two dicts contains the same chromosomes
    if correction_dict.keys() != hp_dict.keys():
        print("Chromosomes don't match for Homopolymer Evaluation.")
        return
    
    output = []
    
    for key in correction_dict.keys():
        # for each chromosome
        corr_err = sorted(correction_dict[key].ocPos + correction_dict[key].ucPos)
        hp_pos = hp_dict[key].strPos
        
        hp_len_counter = defaultdict(int)
        hp_err = defaultdict(float) # error rate in each HP region
        i = j = 0
        
        while i < len(corr_err) and j < len(hp_pos):
            
            hp_len = hp_pos[j][1]-hp_pos[j][0]
            
            if corr_err[i] > hp_pos[j][1]:
                hp_len_counter[hp_len] += 1
                j += 1
            elif corr_err[i] < hp_pos[j][0]:
                i += 1
            else:
                hp_err[hp_len] += 1
                i += 1
                hp_len_counter[hp_len] += 1
                j += 1
        
        hp_len_range = list(hp_len_counter.keys())
        max_len = max(hp_len_range)
        min_len = min(hp_len_range)
        
        for i in range(min_len, max_len+1):
            if hp_len_counter[i]==0:
                continue
            hp_err[i] = hp_err[i] / (hp_len_counter[i]*25)
        
        output.append(hp_err)
        
    # plotting
    fig, axs = plt.subplots(8, 3, sharex=True, sharey=True, 
                        gridspec_kw={'wspace': 0})

    for i in range(8):
        for j in range(3):
            hp_err = output[i*3+j]
            axs[i,j].scatter(hp_err.keys(),hp_err.values())
            axs[i,j].set_title("chr"+str(i*3+j+1))
    #         axs[i,j].set(xlabel='homopolymer length', ylabel='error rate')

    fig.suptitle('correction error vs hp length')
    fig.set_figheight(25)
    fig.set_figwidth(15)

    for ax in axs.flat:
        ax.label_outer()
    
    plt.savefig('error_corr_per_chr.png')
    
    return output


def hp_error_eval(correction_dict, hp_dict):
    '''
    Evaluation of homopolymer error (oc/uc separately) for the whole genome altogether
    '''
    # check if the two dicts contains the same chromosomes
    if correction_dict.keys() != hp_dict.keys():
        print("Chromosomes don't match for Homopolymer Evaluation.")
        return
    
    hp_len_counter = defaultdict(int)
    hp_oc_err = defaultdict(int) # error rate in each HP region
    hp_uc_err = defaultdict(int)
    
    for key in correction_dict.keys():
        oc = sorted(correction_dict[key].ocPos)
        uc = sorted(correction_dict[key].ucPos)
        hp_pos = hp_dict[key].strPos
        
        i = j = 0
        
        while i < len(oc) and j < len(hp_pos):
            
            hp_len = hp_pos[j][1]-hp_pos[j][0]
            
            if oc[i] > hp_pos[j][1]:
                hp_len_counter[hp_len] += 1
                j += 1
            elif oc[i] < hp_pos[j][0]:
                i += 1
            else:
                hp_oc_err[hp_len] += 1
                i += 1
                hp_len_counter[hp_len] += 1
#                 j += 1
                
        i = j = 0
        
        while i < len(uc) and j < len(hp_pos):
            
            hp_len = hp_pos[j][1]-hp_pos[j][0]
            
            if uc[i] > hp_pos[j][1]:
#                 hp_len_counter[hp_len] += 1
                j += 1
            elif uc[i] < hp_pos[j][0]:
                i += 1
            else:
                hp_uc_err[hp_len] += 1
                i += 1
                

    return hp_oc_err,hp_uc_err

'''
python hifieval.py <ref.fa> <sim.maf> <asm.ec.fa>
'''
def main(argv):

    opts, args = getopt.getopt(argv[1:],"g:r:c:", ["genome=","raw=","corr="])
    print(len(args))
    if len(args) < 3:
        print("Usage: hifieval.py -g <ref.fa>|<ref.fq> -r <raw.paf> -c <corr.paf>")
        print("Options:")
        print("  -g STR      Reference Genome fasta/q file")
        print("  -r STR      PAF file with raw reads")
        print("  -c STR      PAF file with error-corrected reads")
    ref_file = raw_paf_file = corr_paf_file = None
    for opt, arg in opts:
        if opt in ['-g','--genome']: ref_file = arg
        elif opt in ['-r','--raw']: raw_paf_file = arg
        elif opt in ['-c','--corr']: corr_paf_file = arg
    
    err_corr_eval = error_correction_eval(raw_paf_file, corr_paf_file)
    hp_info = find_homopolymers(ref_file)
    output = hp_error_chr_eval(err_corr_eval,hp_info)
    
if __name__ == "__main__":
    main(sys.argv)